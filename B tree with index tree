#include <iostream>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <vector>

using namespace std;
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTree;
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTreeNode;

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
struct location_in_IndexBTree {
	Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> * node;
	int index;
};

struct student {
	int ID;	
	string firstName;
	string lastName;
	string DOB;
	string major;
	float GPA;
	//TODO: Add more student info, more features using different info?
	//friend istream& operator >>(istream& s, student& u) {
		// read in a user from disk
	//}

};
//TODO: make staff struct and directory?






template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTreeNode
{

	Index_BTreeNode **C; // An array of child pointers
	
	bool leaf; // Is true when node is leaf. Otherwise false

public:
	int n;     // Current number of keys
	Record **keys;  // An array of keys
	Index_BTreeNode(bool _leaf);
	void traverse();
	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(const IndexKeyType &k);

	int findKey(const IndexKeyType &k);

	void insertNonFull(const Record &k);
	void splitChild(int i, Index_BTreeNode *y);

	void remove(const Record &k);
	void removeFromLeaf(int idx);
	void removeFromNonLeaf(int idx);
	const Record& getPred(int idx);
	const Record& getSucc(int idx);
	void fill(int idx);
	void borrowFromPrev(int idx);
	void borrowFromNext(int idx);
	void merge(int idx);

	friend Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>;
};

template<typename Record, typename PrimaryKeyType, typename Record PrimaryKeyType::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
inline void addMeIn(Record &k, Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *node) {
	node->insert(k);
}
//TODO: delete function


constexpr uint32_t blocksize = 1024; //<- should be 1024 on linux, 4096 on windows 10
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTree
{
	Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *root;
	//BTree<Record, PrimaryKeyType, PrimaryKey> &primary;

public:	//TODO: check that these still work	vv
	constexpr static uint32_t rec_per_block = (blocksize - 8) / (sizeof(Record) + 8);
	constexpr static uint32_t min_rec_per_block = (rec_per_block + 1) / 2;
	constexpr static uint32_t max_rec_per_block = min_rec_per_block * 2 - 1;

	Index_BTree() : root(new Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(true)) {
	}

	void remove(const Record &k);
	void insert(const Record &k);
	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(IndexKeyType k) { //TODO: change to &k?
		return root->search(k);
	}

	void traverse() {
		root->traverse();
	}

};

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::Index_BTreeNode(bool leaf) :leaf(leaf), n(0) {
	keys = new Record *[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block];
	C = new Index_BTreeNode *[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block + 1];

}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
int Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::findKey(const IndexKeyType &k)
{
	int idx = 0;
	while (idx < n && *keys[idx].*IndexKey < k)
		++idx;
	return idx;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k)
{
	Record *x = const_cast<Record*> (&k);
	int idx = findKey(*x.*IndexKey);
	//if (*x.*IndexKey == "Leona")	return;
	//cout << "IIIIII index(tree_i) is: " << idx << ", n = " << n << ", *keys[idx].*IndexKey = " << *keys[idx].*IndexKey << ", *x.*IndexKey = " << *x.*IndexKey << endl;
	if (idx < n && *keys[idx].*IndexKey == *x.*IndexKey) {
		if (leaf) {
			removeFromLeaf(idx);
			cout << "IIIIII REMOVED FROM LEAF" << endl;
		}
		else {
			removeFromNonLeaf(idx);
			cout << "IIIIII REMOVED FROM NON LEAF" << endl;
		}
	}
	else {
		if (leaf) {
			cout << "IIII The key does not exist in the tree\n";
			return;
		}
		cout << "IIIIII GUAC?" << endl;
		bool flag = ((idx == n) ? true : false);

		if (C[idx]->n < Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
			fill(idx);
		if (flag && idx > n)
			C[idx - 1]->remove(k);
		else
			C[idx]->remove(k);
	}
	return;
}




template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromLeaf(int idx) {
	cout << "n = " << n << endl;
	cout << "idx = " << idx << endl;
	for (int i = idx + 1; i < n; ++i) {
		//cout << *keys[i - 1].*IndexKey << " <- " << *keys[i].*IndexKey << "(" << i << ")" << " Next next is: " << *keys[i+2].*IndexKey << endl;
		keys[i - 1] = keys[i];
	}
	n--;
	Record **here = &keys[0];
	cout << "WE DECREASED N to " << n << ", for i btree node: " << here << ", the minimum is: " << Index_BTree< Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>:: min_rec_per_block << endl;
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromNonLeaf(int idx) {
	//Record *x = const_cast<Record*> (&keys[idx]);
	const Record k = (*keys[idx]);

	if (C[idx]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& pred = getPred(idx);
		Record *x = const_cast<Record*> (&pred);
		keys[idx] = x;
		cout << "IIIIII GOTTA REMOVE PRED" << endl;
		C[idx]->remove(pred);
	}

	else if (C[idx + 1]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& succ = getSucc(idx);
		Record *x = const_cast<Record*> (&succ);
		keys[idx] = x;
		cout << "IIIIII GOTTA REMOVE SUCC" << endl;
		C[idx + 1]->remove(succ);
	}

	else {
		merge(idx);
		cout << "IIIIII MERGED" << endl;
		C[idx]->remove(k);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getPred(int idx) {
	Index_BTreeNode *cur = C[idx];
	while (!cur->leaf)
		cur = cur->C[cur->n];

	return *(cur->keys[cur->n - 1]);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getSucc(int idx) {

	Index_BTreeNode *cur = C[idx + 1];
	while (!cur->leaf)
		cur = cur->C[0];

	return *(cur->keys[0]);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::fill(int idx) {

	if (idx != 0 && C[idx - 1]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromPrev(idx);

	else if (idx != n && C[idx + 1]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromNext(idx);

	else {
		if (idx != n)
			merge(idx);
		else
			merge(idx - 1);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromPrev(int idx) {
	Index_BTreeNode *child = C[idx];
	Index_BTreeNode *sibling = C[idx - 1];

	for (int i = child->n - 1; i >= 0; --i)
		child->keys[i + 1] = child->keys[i];

	if (!child->leaf) {
		for (int i = child->n; i >= 0; --i)
			child->C[i + 1] = child->C[i];
	}

	child->keys[0] = keys[idx - 1];

	if (!child->leaf)
		child->C[0] = sibling->C[sibling->n];

	keys[idx - 1] = sibling->keys[sibling->n - 1];

	child->n += 1;
	sibling->n -= 1;

	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromNext(int idx) {
	Index_BTreeNode *child = C[idx];
	Index_BTreeNode *sibling = C[idx + 1];

	child->keys[(child->n)] = keys[idx];

	if (!(child->leaf))
		child->C[(child->n) + 1] = sibling->C[0];

	keys[idx] = sibling->keys[0];

	for (int i = 1; i < sibling->n; ++i)
		sibling->keys[i - 1] = sibling->keys[i];

	if (!sibling->leaf) {
		for (int i = 1; i <= sibling->n; ++i)
			sibling->C[i - 1] = sibling->C[i];
	}

	child->n += 1;
	sibling->n -= 1;
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::merge(int idx) {
	Index_BTreeNode *child = C[idx];
	Index_BTreeNode *sibling = C[idx + 1];

	child->keys[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1] = keys[idx];
	for (int i = 0; i < sibling->n; ++i)
		child->keys[i + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block] = sibling->keys[i];

	if (!child->leaf) {
		for (int i = 0; i <= sibling->n; ++i)
			child->C[i + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block] = sibling->C[i];
	}

	for (int i = idx + 1; i < n; ++i)
		keys[i - 1] = keys[i];

	for (int i = idx + 2; i <= n; ++i)
		C[i - 1] = C[i];

	child->n += sibling->n + 1;
	n--;
	delete(sibling);
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insert(const Record &k) {
	Record *x = const_cast<Record*> (&k);
	//cout << *x.*IndexKey << endl;
	if (root->n == 0) {

		root->keys[0] = x;
		root->n = 1;
	}
	else {
		if (root->n == max_rec_per_block) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>*s = new Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(false);
			s->C[0] = root;
			s->splitChild(0, root);

			int i = 0;
			if (s->keys[0]->*IndexKey < *x.*IndexKey)
				i++;
			s->C[i]->insertNonFull(k);
			root = s;
		}
		else
			root->insertNonFull(k);
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insertNonFull(const Record &k) {
	Record *x = const_cast<Record*> (&k);
	//cout << *x.*IndexKey << endl;

	int i = n - 1;
	if (leaf == true) {
		while (i >= 0 && *keys[i].*IndexKey > *x.*IndexKey) {
			keys[i + 1] = keys[i];
			i--;
		}

		keys[i + 1] = x;
		n = n + 1;
	}
	else {
		while (i >= 0 && *keys[i].*IndexKey > *x.*IndexKey)
			i--;

		if (C[i + 1]->n == Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block) {
			splitChild(i + 1, C[i + 1]);

			if (*keys[i + 1].*IndexKey < *x.*IndexKey)
				i++;
		}
		C[i + 1]->insertNonFull(k);
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::splitChild(int i, Index_BTreeNode *y) {
	Index_BTreeNode *z = new Index_BTreeNode(y->leaf);
	z->n = Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	for (int j = 0; j < Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1; j++)
		z->keys[j] = y->keys[j + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block];

	if (y->leaf == false) {
		for (int j = 0; j < Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block; j++)
			z->C[j] = y->C[j + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block];
	}
	y->n = Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	for (int j = n; j >= i + 1; j--)
		C[j + 1] = C[j];

	C[i + 1] = z;

	for (int j = n - 1; j >= i; j--)
		keys[j + 1] = keys[j];

	keys[i] = y->keys[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1];
	n = n + 1;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::traverse() {
	int i;
	for (i = 0; i < n; i++) {
		if (leaf == false) {
			Record **that = &C[i]->keys[0];
			//cout << endl << "III This node has n = " << C[i]->n << " and adddress: " << that << endl;
			C[i]->traverse();
			//cout << endl << "III END OF THIS NODE WITH n = " << C[i]->n << endl;
		}
		cout << " (" << i << " , " << (*keys[i]).*IndexKey << " , " << (*keys[i]).*PrimaryKey << " , " << keys[i] << ") ";// .ID << "," << keys[i].name << ")";
	}
	//cout << sizeof(Record) << endl; <- TODO: delete but it could help trouble shoot pointers

	if (leaf == false) {
		//cout << endl << "This node has n = " << C[i]->n << endl;
		C[i]->traverse();
		//cout << endl << "END OF THIS NODE WITH n = " << C[i]->n << endl;
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::search(const IndexKeyType &k) {
	int i = 0;
	//cout << "N of i_treenode = " << n << endl;
	while (i < n && k > *keys[i].*IndexKey)
		i++;
	//cout << "k: " << k << endl;
	//cout << "i: " << i << endl;
	if (i < n) {
		if (*keys[i].*IndexKey == k) {
			//cout << "hint" << endl;
			return { this, i };
		}
	}
	//cout << 2 << endl;
	if (leaf == true) {
		//cout << "returning null" << endl;
		return { NULL, NULL };
	}
	//cout << " about to search child for " << k << endl;
	return C[i]->search(k);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k) {		// TODO: possibly change to int k if that makes UI more efficient -- make UI
	if (root->n == 0) {
		cout << "The tree is empty\n";
		return;
	}
	root->remove(k);

	if (root->n == 0) {
		Index_BTreeNode <Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *tmp = root;
		if (root->leaf)
			root->n = 0;
		else
			root = root->C[0];
		delete tmp;
	}
	return;
}










//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================














template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTree;
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTreeNode;

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
struct location_in_BTree {
	BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> * node;
	int index;
};



template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTreeNode
{
	Record *keys;  // An array of keys
	BTreeNode **C; // An array of child pointers
	int n;     // Current number of keys
	bool leaf; // Is true when node is leaf. Otherwise false

public:
	BTreeNode(bool _leaf);
	//TODO: get rid of sync
	void sync(Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
		int i;
		for (i = 0; i < n; i++) {
			if (leaf == false)
				C[i]->sync(i_tree);
			Record *ptr = &keys[i];
			i_tree.insert(*ptr);
		}

		if (leaf == false)
			C[i]->sync(i_tree);
	}

	void traverse() {
		int i;
		for (i = 0; i < n; i++) {
			if (leaf == false) {
				//cout << endl << "This node has n = " << C[i]->n << endl;
				C[i]->traverse();
				//cout << endl << "END OF THIS NODE WITH n = " << C[i]->n << endl;
			}
			Record *ptr = &keys[i];
			cout << " (" << i << " , " << keys[i].*PrimaryKey << " , " << keys[i].*IndexKey << " , " << ptr << "), ";
			//cout << keys[i].ID << ", " << keys[i].firstName << ", " << keys[i].lastName << ", " << keys[i].DOB << ", " << keys[i].major << ", " << keys[i].GPA << endl;
		}

		if (leaf == false) {
			//cout << endl << "This node has n = " << C[i]->n << endl;
			C[i]->traverse();
			//cout << endl << "END OF THIS NODE WITH n = " << C[i]->n << endl;
		}
	}

	location_in_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(const PrimaryKeyType &k);

	int findKey(const PrimaryKeyType &k);

	void insertNonFull(const Record &k, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	void splitChild(int i, BTreeNode *y, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);

	void remove(const Record &k, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	void removeFromLeaf(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	void removeFromNonLeaf(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	const Record& getPred(int idx);
	const Record& getSucc(int idx);
	void fill(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	void borrowFromPrev(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	void borrowFromNext(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	void merge(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);


	friend BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>;
};

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTree
{
	BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *root;
	Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>	i_tree;

public:
	
	constexpr static uint32_t rec_per_block = (blocksize - 8) / (sizeof(Record) + 8);
	constexpr static uint32_t min_rec_per_block = (rec_per_block + 1) / 2;
	constexpr static uint32_t max_rec_per_block = min_rec_per_block * 2 - 1;

	BTree() : root(new BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(true)) {

	}

	void remove(const Record &k);
	Record* insert(const Record &k);
	location_in_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(PrimaryKeyType k) {
		return root->search(k);
	}

	void traverse() {		
		root->traverse();
		cout << endl;
		cout << endl;
		i_tree.traverse();
		cout << endl;
		cout << endl;
	}

	void sync() {
		root->sync(i_tree);
		cout << endl;
		cout << "synced index tree" << endl;
		cout << endl;
		i_tree.traverse();
		cout << endl;
		cout << endl;
		

	}


};

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::BTreeNode(bool leaf) :leaf(leaf), n(0) {
	keys = new Record[BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block];
	C = new BTreeNode *[BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block + 1];

}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
int BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::findKey(const PrimaryKeyType &k)
{
	int idx = 0;
	while (idx < n && keys[idx].*PrimaryKey < k)
		++idx;
	return idx;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree)
{
	cout << "about to findkey for: " << k.*PrimaryKey << " , " << k.*IndexKey << endl;
	int idx = findKey(k.*PrimaryKey);

	if (idx < n && keys[idx].*PrimaryKey == k.*PrimaryKey) {
		//cout << "triggered, index = " << idx << endl;
		if (leaf) {
			cout << "REMOVE FROM LEAF" << endl;
			removeFromLeaf(idx, i_tree);
		}
		else {
			cout << "REMOVE FROM NON LEAF" << endl;
			removeFromNonLeaf(idx, i_tree);
		}
	}
	else {
		if (leaf) {
			cout << "The key does not exist in the tree\n";
			return;
		}

		bool flag = ((idx == n) ? true : false);

		if (C[idx]->n < BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
			fill(idx, i_tree);
			cout << "FILLED" << endl;
		}
		if (flag && idx > n)
			C[idx - 1]->remove(k, i_tree);
		else
			C[idx]->remove(k, i_tree);
	}
	return;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromLeaf(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	int i = idx + 1;
	//Record *should = &keys[idx];
	//cout << "We should be deleting: " << keys[idx].*PrimaryKey << " , " << keys[idx].*IndexKey << " ,located at: " << should << endl;
	//cout << "n = " << n << " , idx = " << idx << endl;
	for (i = idx + 1; i < n; ++i) {

		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[i].*IndexKey);
		if (i_tree_key_loc.node != nullptr) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			i_node.keys[i_tree_key_loc.index] = &keys[i - 1];
		}
		
		//cout << "loop" << endl;
		keys[i - 1] = keys[i];
	}

	//Record *keep = &keys[i - 1];
	//Record *remove = &keys[i];
	//cout << "We want to keep: " << keys[i - 1].*PrimaryKey << " , " << keys[i - 1].*IndexKey << " ,located at: " << keep << endl;
	//cout << "We want to delete: " << keys[i].*PrimaryKey << " , " << keys[i].*IndexKey << " ,located at: " << remove << endl;

	//i_tree.remove(keys[i - 1]);
	n--;


	
	return;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromNonLeaf(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	const Record k = keys[idx];
	if (C[idx]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& pred = getPred(idx);

		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(pred.*IndexKey);
		if (i_tree_key_loc.node != nullptr) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			i_node.keys[i_tree_key_loc.index] = &keys[idx];
		}
		


		keys[idx] = pred;		//key change!
		cout << "Removing pred" << endl;
		C[idx]->remove(pred, i_tree);
	}

	else if (C[idx + 1]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& succ = getSucc(idx);


		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(succ.*IndexKey);		//will probably have to const cast succ
		if (i_tree_key_loc.node != nullptr) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			i_node.keys[i_tree_key_loc.index] = &keys[idx];
		}
		

		keys[idx] = succ;	//key change!
		cout << "Removing succ" << endl;
		C[idx + 1]->remove(succ, i_tree);
	}

	else {
		cout << "about to remove: " << k.*PrimaryKey << " , " << k.*IndexKey << endl;
		merge(idx, i_tree);
		cout << "Merged" << endl;
		cout << "about to remove: " << k.*PrimaryKey << " , " << k.*IndexKey << endl;
		C[idx]->remove(k, i_tree);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getPred(int idx) {
	cout << "getpred" << endl;
	BTreeNode *cur = C[idx];
	while (!cur->leaf)
		cur = cur->C[cur->n];

	return cur->keys[cur->n - 1];
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getSucc(int idx) {
	cout << "getsucc" << endl;
	BTreeNode *cur = C[idx + 1];
	while (!cur->leaf)
		cur = cur->C[0];

	return cur->keys[0];
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::fill(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	cout << "filling" << endl;
	if (idx != 0 && C[idx - 1]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromPrev(idx, i_tree);

	else if (idx != n && C[idx + 1]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromNext(idx, i_tree);

	else {
		if (idx != n)
			merge(idx, i_tree);
		else
			merge(idx - 1, i_tree);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromPrev(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	cout << "Borrowingfromprev" << endl;
	BTreeNode *child = C[idx];
	BTreeNode *sibling = C[idx - 1];

	for (int i = child->n - 1; i >= 0; --i) {
	
		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(child->keys[i].*IndexKey);
		if (i_tree_key_loc.node != nullptr) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			i_node.keys[i_tree_key_loc.index] = &(child->keys[i + 1]);
		}
		else {
			cout << "I should see this at 79" << endl;
		}		
		
		child->keys[i + 1] = child->keys[i];
	}

	if (!child->leaf) {
		for (int i = child->n; i >= 0; --i)
			child->C[i + 1] = child->C[i];
	}


	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[idx - 1].*IndexKey);
	if (i_tree_key_loc.node != nullptr) {
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &(child->keys[0]);
	}

	child->keys[0] = keys[idx - 1];

	if (!child->leaf)
		child->C[0] = sibling->C[sibling->n];

	i_tree_key_loc = i_tree.search(sibling->keys[sibling->n - 1].*IndexKey);
	if (i_tree_key_loc.node != nullptr) {
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &(keys[idx - 1]);
	}

	keys[idx - 1] = sibling->keys[sibling->n - 1];

	child->n += 1;
	sibling->n -= 1;

	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromNext(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	cout << "Borrowingfromnext" << endl;
	BTreeNode *child = C[idx];
	BTreeNode *sibling = C[idx + 1];

	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[idx].*IndexKey);
	if (i_tree_key_loc.node != nullptr) {
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &(child->keys[(child->n)]);
	}

	child->keys[(child->n)] = keys[idx];

	if (!(child->leaf))
		child->C[(child->n) + 1] = sibling->C[0];

	i_tree_key_loc = i_tree.search(sibling->keys[0].*IndexKey);
	if (i_tree_key_loc.node != nullptr) {
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &(keys[idx]);
	}

	keys[idx] = sibling->keys[0];

	for (int i = 1; i < sibling->n; ++i) {
		i_tree_key_loc = i_tree.search(sibling->keys[i].*IndexKey);
		if (i_tree_key_loc.node != nullptr) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			i_node.keys[i_tree_key_loc.index] = &(sibling->keys[i - 1]);
		}

		sibling->keys[i - 1] = sibling->keys[i];
	}

	if (!sibling->leaf) {
		for (int i = 1; i <= sibling->n; ++i)
			sibling->C[i - 1] = sibling->C[i];
	}

	child->n += 1;
	sibling->n -= 1;
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::merge(int idx, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	cout << "MERGING" << endl;
	BTreeNode *child = C[idx];
	BTreeNode *sibling = C[idx + 1];
	int minRec = BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block;
	cout << "About to search for: " << keys[idx].*IndexKey << endl;
	
	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[idx].*IndexKey);
	if (i_tree_key_loc.node != nullptr) {
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &(child->keys[minRec - 1]);
	}
	else {
		cout << "I should see this at 86" << endl;
	}

	child->keys[minRec - 1] = keys[idx];		//key change

	for (int i = 0; i < sibling->n; ++i) {
		cout << "Now About to search for: " << sibling->keys[i].*IndexKey  << endl;
		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(sibling->keys[i].*IndexKey);
		if (i_tree_key_loc.node != nullptr) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>i_node = *i_tree_key_loc.node;
			i_node.keys[i_tree_key_loc.index] = &(child->keys[i + minRec]);
		}
		else {
			cout << "I should see this at 67" << endl;
		}

		
		child->keys[i + minRec] = sibling->keys[i];		//key change
	}

	if (!child->leaf) {
		for (int i = 0; i <= sibling->n; ++i)
			child->C[i + minRec] = sibling->C[i];
	}

	for (int i = idx + 1; i < n; ++i) {
		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[i].*IndexKey);
		if (i_tree_key_loc.node != nullptr) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			i_node.keys[i_tree_key_loc.index] = &(keys[i - 1]);
		}
		
		keys[i - 1] = keys[i];		//key change
	}

	for (int i = idx + 2; i <= n; ++i)
		C[i - 1] = C[i];

	child->n += sibling->n + 1;
	n--;
	delete(sibling); //TODO-> does this affect the pointers? idts, i hope not
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
Record* BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insert(const Record &k) {	//TODO: make void?
	
	if (root->n == 0) {
		//cout << "empty" << endl;
		root->keys[0] = k;
		root->n = 1;
		Record* ptr = &(root->keys[0]);
		i_tree.insert(*ptr);
		return ptr;
	}


	else {
		if (root->n == max_rec_per_block) {
			//cout << "full" << endl;
			BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>*s = new BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(false);
			s->C[0] = root;
			s->splitChild(0, root, i_tree);

			int i = 0;
			if (s->keys[0].*PrimaryKey < k.*PrimaryKey)
				i++;
			
			s->C[i]->insertNonFull(k, i_tree);
			root = s;
		}
		else {
			//cout << "not full" << endl;
			root->insertNonFull(k, i_tree);
		}
	}

	Record* ptr = &(root->keys[root->n - 1]); //TODO: can't use root
	//cout << k.firstName << " @ " << ptr << " In Primary Tree." << endl;
	//i_tree.insert(*ptr);
	return ptr;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insertNonFull(const Record &k, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	int i = n - 1;
	if (leaf == true) {

		while (i >= 0 && keys[i].*PrimaryKey > k.*PrimaryKey) { //TODO: analyze complexity for report logn^2?
			//swap these pointers in i_tree keys** (array of pointers)
			//cout << "keys[i + 1]: " << keys[i + 1].*PrimaryKey << " , " << keys[i + 1].*IndexKey << endl;
			//cout << "keys[i]: " << keys[i].*PrimaryKey << " , " << keys[i].*IndexKey << endl;
			//cout << "BEFORE SEARCH" << endl;
			location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[i].*IndexKey);
			//cout << "AFTER SEARCH" << endl;
			//cout << i_tree_key_loc.index << endl;
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			//cout << *test.keys[i_tree_key_loc.index] << endl;
			i_node.keys[i_tree_key_loc.index] = &keys[i+1];
			//cout << "testing" << endl;
			//cout << i_node.keys[i_tree_key_loc.index] << " is now: " << &keys[i + 1] << endl;
				
			
			keys[i + 1] = keys[i];
			i--;
		}
		keys[i + 1] = k;
		n = n + 1;
		Record* ptr = &(keys[i + 1]);
		//cout << "ABOUT TO INSERT " << *ptr.*PrimaryKey << " , " << *ptr.*IndexKey << " , " << ptr << endl;
		i_tree.insert(*ptr);
	}
	else {
		while (i >= 0 && keys[i].*PrimaryKey > k.*PrimaryKey)
			i--;

		if (C[i + 1]->n == BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block) {
			splitChild(i + 1, C[i + 1], i_tree);
			if (keys[i + 1].*PrimaryKey < k.*PrimaryKey)
				i++;
		}
		
		C[i + 1]->insertNonFull(k, i_tree);
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::splitChild(int i, BTreeNode *y, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	int minRecs = BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block;
	BTreeNode *z = new BTreeNode(y->leaf);
	z->n = BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	for (int j = 0; j < BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1; j++) {
		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(y->keys[j + minRecs].*IndexKey);
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &(z->keys[j]);

		z->keys[j] = y->keys[j + minRecs];
	}

	if (y->leaf == false) {
		for (int j = 0; j < BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block; j++)
			z->C[j] = y->C[j + BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block];

	}
	y->n = BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	for (int j = n; j >= i + 1; j--)
		C[j + 1] = C[j];

	C[i + 1] = z;

	for (int j = n - 1; j >= i; j--) {
		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[j].*IndexKey);
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &keys[j + 1];
		
		keys[j + 1] = keys[j];
	}

	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(y->keys[minRecs - 1].*IndexKey);
	Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
	i_node.keys[i_tree_key_loc.index] = &keys[i];

	keys[i] = y->keys[minRecs - 1];
	n = n + 1;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
location_in_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::search(const PrimaryKeyType &k) {
	
	int i = 0;
	while (i < n && k > keys[i].*PrimaryKey)
		i++;

	if (keys[i].*PrimaryKey == k)
		return { this, i };

	if (leaf == true)
		return { NULL, NULL };

	return C[i]->search(k);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k) {		// TODO: possibly change to int k if that makes UI more efficient -- make UI
	if (root->n == 0) {
		cout << "The tree is empty\n";
		return;
	}	

	i_tree.remove(k);
	root->remove(k, i_tree);

	if (root->n == 0) {
		BTreeNode <Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *tmp = root;
		if (root->leaf)
			root->n = 0;
		else
			root = root->C[0];
		delete tmp;
	}
	return;
}





//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================










int main() {
	BTree<student, int, &student::ID, string, &student::firstName> t;
	//BTree<student, string, &student::firstName, string, &student::lastName> t;
	int count = 0;
	ifstream myCSV("Student Database Data Table.csv");
	string line;	
	while (getline(myCSV, line, '\n')) {
		if (line != "First Name,Last Name,ID,Birthdate,Major,GPA") {
			count++;
			vector<string> result;
			stringstream s_stream(line); //create string stream from the string
			while (s_stream.good()) {
				string substr;
				getline(s_stream, substr, ','); //get first string delimited by comma
				result.push_back(substr);
			}

			string FN = result.at(0);
			string LN = result.at(1);
			string ID_str = result.at(2);
			stringstream to_int(ID_str);
			int ID = 0;
			to_int >> ID;
			string DOB = result.at(3);
			string Major = result.at(4);
			string GPA_str = result.at(5);
			float GPA = stof(GPA_str);
			//cout << endl << count << endl;
			t.insert({ ID, FN, LN, DOB, Major, GPA });
			//cout << count << ": Inserted: " << ID << " , " << FN << endl;
			//t.traverse();		//	<--POINTER ANALYSIS
		}
	}
	t.traverse();

	ifstream myCSV2("Student Database Data Table.csv");
	while (getline(myCSV2, line, '\n')) {
		if (line != "First Name,Last Name,ID,Birthdate,Major,GPA") {
			count--;
			vector<string> result;
			stringstream s_stream(line); //create string stream from the string
			while (s_stream.good()) {
				string substr;
				getline(s_stream, substr, ','); //get first string delimited by comma
				result.push_back(substr);
			}

			string FN = result.at(0);
			string LN = result.at(1);
			string ID_str = result.at(2);
			stringstream to_int(ID_str);
			int ID = 0;
			to_int >> ID;
			string DOB = result.at(3);
			string Major = result.at(4);
			string GPA_str = result.at(5);
			float GPA = stof(GPA_str);
			//cout << endl << count << endl;
			t.remove({ ID, FN, LN, DOB, Major, GPA });
			cout << count << ": deleted: " << ID << " , " << FN << ":" << endl;
			t.traverse();		//	<--POINTER ANALYSIS
		}
	}
	//t.traverse();
	//HAVE FUNCTION RETURN INDEX BTREE IF YOU WANT TO MANIPULATE FROM MAIN, maybe on insert if it was empty, check efficiency
	//location_in_BTree<student, int, &student::ID, string, &student::firstName> test = t.search(1026);
	//cout << test.node << endl;
	//cout << test.index << endl;
	cout << endl << "finished removals, tree is empty" << endl;
	t.remove({1026, "Philip", "Gibson", "6/5/2001", "Biology", 2.627});	//TODO: look into "truncation double to float" warning
	cout << "tried to remove Philip Giboson (1026)" << endl;


	




	system("pause");
	return 0;
}
