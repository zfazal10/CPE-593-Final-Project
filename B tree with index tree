#include <iostream>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <vector>

using namespace std;
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTree;
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTreeNode;

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
struct location_in_IndexBTree {
	Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> * node;
	int index;
};

struct student {
	int ID;	
	string firstName;
	string lastName;
	string DOB;
	string major;
	float GPA;
	//TODO: Add more student info, more features using different info?
	//friend istream& operator >>(istream& s, student& u) {
		// read in a user from disk
	//}

};
//TODO: make staff struct and directory?




template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTreeNode
{

	Index_BTreeNode **C; // An array of child pointers
	int n;     // Current number of keys
	bool leaf; // Is true when node is leaf. Otherwise false

public:
	Record **keys;  // An array of keys
	Index_BTreeNode(bool _leaf);
	void traverse();
	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(const IndexKeyType &k);

	int findKey(const IndexKeyType &k);

	void insertNonFull(const Record &k);
	void splitChild(int i, Index_BTreeNode *y);

	void remove(const Record &k);
	void removeFromLeaf(int idx);
	void removeFromNonLeaf(int idx);
	const Record& getPred(int idx);
	const Record& getSucc(int idx);
	void fill(int idx);
	void borrowFromPrev(int idx);
	void borrowFromNext(int idx);
	void merge(int idx);

	friend Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>;
};

template<typename Record, typename PrimaryKeyType, typename Record PrimaryKeyType::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
inline void addMeIn(Record &k, Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *node) {
	node->insert(k);
}
//TODO: delete function


constexpr uint32_t blocksize = 1024; //<- windows 10 block size	//TODO: get ride of this line?
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class Index_BTree
{
	Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *root;
	//BTree<Record, PrimaryKeyType, PrimaryKey> &primary;

public:	//TODO: check that these still work	vv
	constexpr static uint32_t rec_per_block = (blocksize - 8) / (sizeof(Record) + 8);
	constexpr static uint32_t min_rec_per_block = (rec_per_block + 1) / 2;
	constexpr static uint32_t max_rec_per_block = min_rec_per_block * 2 - 1;

	Index_BTree() : root(new Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(true)) {
	}

	void remove(const Record &k);
	void insert(const Record &k);
	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(IndexKeyType k) { //TODO: change to &k?
		return root->search(k);
	}

	void traverse() {
		root->traverse();
	}

};

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::Index_BTreeNode(bool leaf) :leaf(leaf), n(0) {
	keys = new Record *[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block];
	C = new Index_BTreeNode *[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block + 1];

}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
int Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::findKey(const IndexKeyType &k)
{
	int idx = 0;
	while (idx < n && *keys[idx].*IndexKey < k)
		++idx;
	return idx;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k)
{
	Record *x = const_cast<Record*> (&k);
	int idx = findKey(*x.*IndexKey);
	cout << "index(tree_i) is: " << idx << ", n = " << n << ", *keys[idx].*IndexKey = " << *keys[idx].*IndexKey << ", *x.*IndexKey = " << *x.*IndexKey << endl;
	if (idx < n && *keys[idx].*IndexKey == *x.*IndexKey) {
		cout << "Index triggered" << endl;
		if (leaf)
			removeFromLeaf(idx);
		else
			removeFromNonLeaf(idx);
	}
	else {
		if (leaf) {
			cout << "The key does not exist in the tree\n";
			return;
		}

		bool flag = ((idx == n) ? true : false);

		if (C[idx]->n < Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
			fill(idx);
		if (flag && idx > n)
			C[idx - 1]->remove(k);
		else
			C[idx]->remove(k);
	}
	return;
}




template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromLeaf(int idx) {
	for (int i = idx + 1; i < n; ++i)
		keys[i - 1] = keys[i];
	n--;
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromNonLeaf(int idx) {
	//Record *x = const_cast<Record*> (&keys[idx]);
	const Record k = (*keys[idx]);

	if (C[idx]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& pred = getPred(idx);
		Record *x = const_cast<Record*> (&pred);
		keys[idx] = x;
		C[idx]->remove(pred);
	}

	else if (C[idx + 1]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& succ = getSucc(idx);
		Record *x = const_cast<Record*> (&succ);
		keys[idx] = x;
		C[idx + 1]->remove(succ);
	}

	else {
		merge(idx);
		C[idx]->remove(k);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getPred(int idx) {
	Index_BTreeNode *cur = C[idx];
	while (!cur->leaf)
		cur = cur->C[cur->n];

	return *(cur->keys[cur->n - 1]);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getSucc(int idx) {

	Index_BTreeNode *cur = C[idx + 1];
	while (!cur->leaf)
		cur = cur->C[0];

	return *(cur->keys[0]);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::fill(int idx) {

	if (idx != 0 && C[idx - 1]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromPrev(idx);

	else if (idx != n && C[idx + 1]->n >= Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromNext(idx);

	else {
		if (idx != n)
			merge(idx);
		else
			merge(idx - 1);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromPrev(int idx) {
	Index_BTreeNode *child = C[idx];
	Index_BTreeNode *sibling = C[idx - 1];

	for (int i = child->n - 1; i >= 0; --i)
		child->keys[i + 1] = child->keys[i];

	if (!child->leaf) {
		for (int i = child->n; i >= 0; --i)
			child->C[i + 1] = child->C[i];
	}

	child->keys[0] = keys[idx - 1];

	if (!child->leaf)
		child->C[0] = sibling->C[sibling->n];

	keys[idx - 1] = sibling->keys[sibling->n - 1];

	child->n += 1;
	sibling->n -= 1;

	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromNext(int idx) {
	Index_BTreeNode *child = C[idx];
	Index_BTreeNode *sibling = C[idx + 1];

	child->keys[(child->n)] = keys[idx];

	if (!(child->leaf))
		child->C[(child->n) + 1] = sibling->C[0];

	keys[idx] = sibling->keys[0];

	for (int i = 1; i < sibling->n; ++i)
		sibling->keys[i - 1] = sibling->keys[i];

	if (!sibling->leaf) {
		for (int i = 1; i <= sibling->n; ++i)
			sibling->C[i - 1] = sibling->C[i];
	}

	child->n += 1;
	sibling->n -= 1;
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::merge(int idx) {
	Index_BTreeNode *child = C[idx];
	Index_BTreeNode *sibling = C[idx + 1];

	child->keys[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1] = keys[idx];
	for (int i = 0; i < sibling->n; ++i)
		child->keys[i + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block] = sibling->keys[i];

	if (!child->leaf) {
		for (int i = 0; i <= sibling->n; ++i)
			child->C[i + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block] = sibling->C[i];
	}

	for (int i = idx + 1; i < n; ++i)
		keys[i - 1] = keys[i];

	for (int i = idx + 2; i <= n; ++i)
		C[i - 1] = C[i];

	child->n += sibling->n + 1;
	n--;
	delete(sibling);
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insert(const Record &k) {
	Record *x = const_cast<Record*> (&k);
	//cout << *x.*IndexKey << endl;
	if (root->n == 0) {

		root->keys[0] = x;
		root->n = 1;
	}
	else {
		if (root->n == max_rec_per_block) {
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>*s = new Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(false);
			s->C[0] = root;
			s->splitChild(0, root);

			int i = 0;
			if (s->keys[0]->*IndexKey < *x.*IndexKey)
				i++;
			s->C[i]->insertNonFull(k);
			root = s;
		}
		else
			root->insertNonFull(k);
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insertNonFull(const Record &k) {
	Record *x = const_cast<Record*> (&k);
	//cout << *x.*IndexKey << endl;

	int i = n - 1;
	if (leaf == true) {
		while (i >= 0 && *keys[i].*IndexKey > *x.*IndexKey) {
			keys[i + 1] = keys[i];
			i--;
		}

		keys[i + 1] = x;
		n = n + 1;
	}
	else {
		while (i >= 0 && *keys[i].*IndexKey > *x.*IndexKey)
			i--;

		if (C[i + 1]->n == Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block) {
			splitChild(i + 1, C[i + 1]);

			if (*keys[i + 1].*IndexKey < *x.*IndexKey)
				i++;
		}
		C[i + 1]->insertNonFull(k);
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::splitChild(int i, Index_BTreeNode *y) {
	Index_BTreeNode *z = new Index_BTreeNode(y->leaf);
	z->n = Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	for (int j = 0; j < Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1; j++)
		z->keys[j] = y->keys[j + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block];

	if (y->leaf == false) {
		for (int j = 0; j < Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block; j++)
			z->C[j] = y->C[j + Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block];
	}
	y->n = Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	for (int j = n; j >= i + 1; j--)
		C[j + 1] = C[j];

	C[i + 1] = z;

	for (int j = n - 1; j >= i; j--)
		keys[j + 1] = keys[j];

	keys[i] = y->keys[Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1];
	n = n + 1;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::traverse() {
	int i;
	for (i = 0; i < n; i++) {
		if (leaf == false) {
			cout << endl << "This node has n = " << C[i]->n << endl;
			C[i]->traverse();
			cout << endl << "END OF THIS NODE WITH n = " << C[i]->n << endl;
		}
		cout << " (" << i << " , " << (*keys[i]).*IndexKey << " , " << (*keys[i]).*PrimaryKey << " , " << keys[i] << ") ";// .ID << "," << keys[i].name << ")";
	}
	//cout << sizeof(Record) << endl; <- TODO: delete but it could help trouble shoot pointers

	if (leaf == false) {
		cout << endl << "This node has n = " << C[i]->n << endl;
		C[i]->traverse();
		cout << endl << "END OF THIS NODE WITH n = " << C[i]->n << endl;
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::search(const IndexKeyType &k) {
	int i = 0;
	//cout << "N of i_treenode = " << n << endl;
	while (i < n && k > *keys[i].*IndexKey)
		i++;
	//cout << "k: " << k << endl;
	//cout << "i: " << i << endl;
	if (i < n) {
		if (*keys[i].*IndexKey == k) {
			//cout << "hint" << endl;
			return { this, i };
		}
	}
	//cout << 2 << endl;
	if (leaf == true) {
		//cout << "returning null" << endl;
		return { NULL, NULL };
	}
	//cout << " about to search child for " << k << endl;
	return C[i]->search(k);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k) {		// TODO: possibly change to int k if that makes UI more efficient -- make UI
	if (root->n == 0) {
		cout << "The tree is empty\n";
		return;
	}
	root->remove(k);

	if (root->n == 0) {
		Index_BTreeNode <Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *tmp = root;
		if (root->leaf)
			root->n = 0;
		else
			root = root->C[0];
		delete tmp;
	}
	return;
}










//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================
//================================================================	End of Index Classes ===================================================================














template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTree;
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTreeNode;

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
struct location_in_BTree {
	BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> * node;
	int index;
};



template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTreeNode
{
	Record *keys;  // An array of keys
	BTreeNode **C; // An array of child pointers
	int n;     // Current number of keys
	bool leaf; // Is true when node is leaf. Otherwise false

public:
	BTreeNode(bool _leaf);

	void sync(Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
		int i;
		for (i = 0; i < n; i++) {
			if (leaf == false)
				C[i]->sync(i_tree);
			Record *ptr = &keys[i];
			i_tree.insert(*ptr);
		}

		if (leaf == false)
			C[i]->sync(i_tree);
	}

	void traverse() {
		int i;
		for (i = 0; i < n; i++) {
			if (leaf == false) {
				cout << endl << "This node has n = " << C[i]->n << endl;
				C[i]->traverse();
				cout << endl << "END OF THIS NODE WITH n = " << C[i]->n << endl;
			}
			Record *ptr = &keys[i];
			cout << " (" << i << " , " << keys[i].*PrimaryKey << " , " << keys[i].*IndexKey << " , " << ptr << "), ";
			//cout << keys[i].ID << ", " << keys[i].firstName << ", " << keys[i].lastName << ", " << keys[i].DOB << ", " << keys[i].major << ", " << keys[i].GPA << endl;
		}

		if (leaf == false) {
			cout << endl << "This node has n = " << C[i]->n << endl;
			C[i]->traverse();
			cout << endl << "END OF THIS NODE WITH n = " << C[i]->n << endl;
		}
	}

	location_in_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(const PrimaryKeyType &k);

	int findKey(const PrimaryKeyType &k);

	void insertNonFull(const Record &k, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);
	void splitChild(int i, BTreeNode *y, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree);

	void remove(const Record &k);
	void removeFromLeaf(int idx);
	void removeFromNonLeaf(int idx);
	const Record& getPred(int idx);
	const Record& getSucc(int idx);
	void fill(int idx);
	void borrowFromPrev(int idx);
	void borrowFromNext(int idx);
	void merge(int idx);


	friend BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>;		//maybe move inside BTree
};

//constexpr uint32_t blocksize = 4096; //<- windows 10 block size	
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
class BTree
{
	BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *root;
	Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>	i_tree;

public:
	
	constexpr static uint32_t rec_per_block = (blocksize - 8) / (sizeof(Record) + 8);
	constexpr static uint32_t min_rec_per_block = (rec_per_block + 1) / 2;
	constexpr static uint32_t max_rec_per_block = min_rec_per_block * 2 - 1;

	BTree() : root(new BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(true)) {

	}

	void remove(const Record &k);
	Record* insert(const Record &k);
	location_in_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> search(PrimaryKeyType k) {
		return root->search(k);
	}

	void traverse() {		
		root->traverse();
		cout << endl;
		cout << endl;
		i_tree.traverse();
		cout << endl;
		cout << endl;
	}

	void sync() {
		root->sync(i_tree);
		cout << endl;
		cout << "synced index tree" << endl;
		cout << endl;
		i_tree.traverse();
		cout << endl;
		cout << endl;
		

	}


};

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::BTreeNode(bool leaf) :leaf(leaf), n(0) {
	keys = new Record[BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block];
	C = new BTreeNode *[BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block + 1];

}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
int BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::findKey(const PrimaryKeyType &k)
{
	int idx = 0;
	while (idx < n && keys[idx].*PrimaryKey < k)
		++idx;
	return idx;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k)
{
	int idx = findKey(k.*PrimaryKey);

	if (idx < n && keys[idx].*PrimaryKey == k.*PrimaryKey) {
		cout << "triggered, index = " << idx << endl;
		if (leaf)
			removeFromLeaf(idx);
		else
			removeFromNonLeaf(idx);
	}
	else {
		if (leaf) {
			cout << "The key does not exist in the tree\n";
			return;
		}

		bool flag = ((idx == n) ? true : false);

		if (C[idx]->n < BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) //TODO: do we need class?
			fill(idx);
		if (flag && idx > n)
			C[idx - 1]->remove(k);
		else
			C[idx]->remove(k);
	}
	return;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromLeaf(int idx) {
	for (int i = idx + 1; i < n; ++i)
		keys[i - 1] = keys[i];
	n--;
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::removeFromNonLeaf(int idx) {
	const Record& k = keys[idx];
	if (C[idx]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& pred = getPred(idx);
		keys[idx] = pred;
		C[idx]->remove(pred);
	}

	else if (C[idx + 1]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block) {
		const Record& succ = getSucc(idx);
		keys[idx] = succ;
		C[idx + 1]->remove(succ);
	}

	else {
		merge(idx);
		C[idx]->remove(k);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getPred(int idx) {
	BTreeNode *cur = C[idx];
	while (!cur->leaf)
		cur = cur->C[cur->n];

	return cur->keys[cur->n - 1];
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
const Record& BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::getSucc(int idx) {

	BTreeNode *cur = C[idx + 1];
	while (!cur->leaf)
		cur = cur->C[0];

	return cur->keys[0];
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::fill(int idx) {

	if (idx != 0 && C[idx - 1]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromPrev(idx);

	else if (idx != n && C[idx + 1]->n >= BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block)
		borrowFromNext(idx);

	else {
		if (idx != n)
			merge(idx);
		else
			merge(idx - 1);
	}
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromPrev(int idx) {
	BTreeNode *child = C[idx];
	BTreeNode *sibling = C[idx - 1];

	for (int i = child->n - 1; i >= 0; --i)
		child->keys[i + 1] = child->keys[i];

	if (!child->leaf) {
		for (int i = child->n; i >= 0; --i)
			child->C[i + 1] = child->C[i];
	}

	child->keys[0] = keys[idx - 1];

	if (!child->leaf)
		child->C[0] = sibling->C[sibling->n];

	keys[idx - 1] = sibling->keys[sibling->n - 1];

	child->n += 1;
	sibling->n -= 1;

	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::borrowFromNext(int idx) {
	BTreeNode *child = C[idx];
	BTreeNode *sibling = C[idx + 1];

	child->keys[(child->n)] = keys[idx];

	if (!(child->leaf))
		child->C[(child->n) + 1] = sibling->C[0];

	keys[idx] = sibling->keys[0];

	for (int i = 1; i < sibling->n; ++i)
		sibling->keys[i - 1] = sibling->keys[i];

	if (!sibling->leaf) {
		for (int i = 1; i <= sibling->n; ++i)
			sibling->C[i - 1] = sibling->C[i];
	}

	child->n += 1;
	sibling->n -= 1;
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::merge(int idx) {
	BTreeNode *child = C[idx];
	BTreeNode *sibling = C[idx + 1];

	child->keys[BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1] = keys[idx];
	for (int i = 0; i < sibling->n; ++i)
		child->keys[i + BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block] = sibling->keys[i];

	if (!child->leaf) {
		for (int i = 0; i <= sibling->n; ++i)
			child->C[i + BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block] = sibling->C[i];
	}

	for (int i = idx + 1; i < n; ++i)
		keys[i - 1] = keys[i];

	for (int i = idx + 2; i <= n; ++i)
		C[i - 1] = C[i];

	child->n += sibling->n + 1;
	n--;
	delete(sibling);
	return;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
Record* BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insert(const Record &k) {	//TODO: make void?
	
	if (root->n == 0) {
		//cout << "empty" << endl;
		root->keys[0] = k;
		root->n = 1;
		Record* ptr = &(root->keys[0]);
		i_tree.insert(*ptr);
		return ptr;
	}


	else {
		if (root->n == max_rec_per_block) {
			cout << "full" << endl;
			BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>*s = new BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>(false);
			s->C[0] = root;
			s->splitChild(0, root, i_tree);

			int i = 0;
			if (s->keys[0].*PrimaryKey < k.*PrimaryKey)
				i++;
			
			s->C[i]->insertNonFull(k, i_tree);
			root = s;
		}
		else {
			//cout << "not full" << endl;
			root->insertNonFull(k, i_tree);
		}
	}

	Record* ptr = &(root->keys[root->n - 1]); //TODO: can't use root
	//cout << k.firstName << " @ " << ptr << " In Primary Tree." << endl;
	//i_tree.insert(*ptr);
	return ptr;
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::insertNonFull(const Record &k, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	cout << endl << "n = " << n << endl;
	int i = n - 1;
	if (leaf == true) {

		while (i >= 0 && keys[i].*PrimaryKey > k.*PrimaryKey) { //TODO: analyze complexity for report logn^2?
			//swap these pointers in i_tree keys** (array of pointers)
			cout << "keys[i + 1]: " << keys[i + 1].*PrimaryKey << " , " << keys[i + 1].*IndexKey << endl;
			cout << "keys[i]: " << keys[i].*PrimaryKey << " , " << keys[i].*IndexKey << endl;
			//Record *new_location = &keys[i + 1];
			//Record *og_location = &keys[i];
			//cout << "BEFORE SEARCH" << endl;
			location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[i].*IndexKey);
			//cout << "AFTER SEARCH" << endl;
			//cout << i_tree_key_loc.index << endl;
			Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
			//cout << *test.keys[i_tree_key_loc.index] << endl;
			i_node.keys[i_tree_key_loc.index] = &keys[i+1];
			//cout << "testing" << endl;
			//cout << i_node.keys[i_tree_key_loc.index] << " is now: " << &keys[i + 1] << endl;
				
			
			keys[i + 1] = keys[i];
			i--;
		}
		keys[i + 1] = k;
		n = n + 1;
		Record* ptr = &(keys[i + 1]);
		//cout << "ABOUT TO INSERT " << *ptr.*PrimaryKey << " , " << *ptr.*IndexKey << " , " << ptr << endl;
		i_tree.insert(*ptr);
	}
	else {
		while (i >= 0 && keys[i].*PrimaryKey > k.*PrimaryKey)
			i--;

		if (C[i + 1]->n == BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::max_rec_per_block) {
			splitChild(i + 1, C[i + 1], i_tree);
			if (keys[i + 1].*PrimaryKey < k.*PrimaryKey)
				i++;
		}
		
		C[i + 1]->insertNonFull(k, i_tree);
	}
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::splitChild(int i, BTreeNode *y, Index_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> &i_tree) {
	cout << endl << "SHIT================================================" << endl;
	int minRecs = BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block;
	BTreeNode *z = new BTreeNode(y->leaf);
	z->n = BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	//look at the 2 spots where keys are changing, does pointer changes affect shit? you got this, stay focused and grind.

	for (int j = 0; j < BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1; j++) {
		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(y->keys[j + minRecs].*IndexKey);
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &(z->keys[j]);

		z->keys[j] = y->keys[j + minRecs];
	}

	if (y->leaf == false) {
		for (int j = 0; j < BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block; j++) {
			cout << "CASE 1 =============================================================" << endl;
			//system("pause");
			z->C[j] = y->C[j + BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block];
			//TODO: does this ever happen? does this change the pointer value of keys in these children? test with smaller block size
		}
	}
	y->n = BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::min_rec_per_block - 1;

	for (int j = n; j >= i + 1; j--) {
		cout << "CASE 2 =============================================================" << endl;
		//system("pause");
		C[j + 1] = C[j]; //above comment applies here to**	
	}

	C[i + 1] = z; //actualy i think we are good because these are just pointers*** test it out tho

	for (int j = n - 1; j >= i; j--) {
		cout << "NEW CASE HERE =============================================================" << endl;
		cout << "NEW CASE HERE =============================================================" << endl;
		cout << "NEW CASE HERE =============================================================" << endl;
		//system("pause");
		location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(keys[j].*IndexKey);
		Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
		i_node.keys[i_tree_key_loc.index] = &keys[j + 1];
		
		keys[j + 1] = keys[j];
	}

	location_in_IndexBTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_tree_key_loc = i_tree.search(y->keys[minRecs - 1].*IndexKey);
	Index_BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> i_node = *i_tree_key_loc.node;
	i_node.keys[i_tree_key_loc.index] = &keys[i];

	keys[i] = y->keys[minRecs - 1];
	n = n + 1;
}

template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
location_in_BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> BTreeNode<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::search(const PrimaryKeyType &k) {
	
	int i = 0;
	while (i < n && k > keys[i].*PrimaryKey)
		i++;

	if (keys[i].*PrimaryKey == k)
		return { this, i };

	if (leaf == true)
		return { NULL, NULL };

	return C[i]->search(k);
}
template<typename Record, typename PrimaryKeyType, PrimaryKeyType Record::*PrimaryKey, typename IndexKeyType, IndexKeyType Record::*IndexKey>
void BTree<Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey>::remove(const Record &k) {		// TODO: possibly change to int k if that makes UI more efficient -- make UI
	if (root->n == 0) {
		cout << "The tree is empty\n";
		return;
	}

	
	root->remove(k);
	//cout << endl;
	//cout << "Debug Traverse 1:" << endl;
	//cout << endl;
	//i_tree.traverse();
	//cout << endl;
	Record *ptr = const_cast<Record*>(&k);
	//i_tree.remove(*ptr);
	//cout << endl;
	//cout << "Debug Traverse 2:" << endl;
	//cout << endl;
	//i_tree.traverse();
	//cout << endl;

	if (root->n == 0) {
		BTreeNode <Record, PrimaryKeyType, PrimaryKey, IndexKeyType, IndexKey> *tmp = root;
		if (root->leaf)
			root->n = 0;
		else
			root = root->C[0];
		delete tmp;
	}
	return;
}





//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================
//================================================================	Beginning of main function ===================================================================










int main() {
	BTree<student, int, &student::ID, string, &student::firstName> t;
	//BTree<student, string, &student::firstName, string, &student::lastName> t;
	int count = 0;
	ifstream myCSV("Student Database Data Table.csv");
	string line;	
	while (getline(myCSV, line, '\n')) {
		if (line != "First Name,Last Name,ID,Birthdate,Major,GPA") {
			count++;
			vector<string> result;
			stringstream s_stream(line); //create string stream from the string
			while (s_stream.good()) {
				string substr;
				getline(s_stream, substr, ','); //get first string delimited by comma
				result.push_back(substr);
			}

			string FN = result.at(0);
			string LN = result.at(1);
			string ID_str = result.at(2);
			stringstream to_int(ID_str);
			int ID = 0;
			to_int >> ID;
			string DOB = result.at(3);
			string Major = result.at(4);
			string GPA_str = result.at(5);
			float GPA = stof(GPA_str);
			cout << endl << count << endl;
			t.insert({ ID, FN, LN, DOB, Major, GPA });
			cout << count << ": Inserted: " << ID << " , " << FN << endl;
			t.traverse();		//	<--POINTER ANALYSIS
		}
	}

	//HAVE FUNCTION RETURN INDEX BTREE IF YOU WANT TO MANIPULATE FROM MAIN, maybe on insert if it was empty, check efficiency
	//location_in_BTree<student, int, &student::ID, string, &student::firstName> test = t.search(1026);
	//cout << test.node << endl;
	//cout << test.index << endl;
	
	//t.remove({1026, "Philip", "Gibson", "6/5/2001", "Biology", 2.627});
	//cout << "removed Philip Giboson (1026)" << endl;
//	t.traverse();

	


#if 0
	t.insert({ 3, "Steve" });
	//i.insert({ 3, "Steve" });
	cout << 3 << endl;
	t.insert({ 7, "Phil" });
	//i.insert({ 7, "Phil" });
	cout << 7 << endl;
	t.insert({ 10, "Zack" });
	cout << 10 << endl;
	t.insert({ 11, "Rick" });
	cout << 11 << endl;
	t.insert({ 13, "Mike" });
	cout << 13 << endl;
	t.insert({ 14, "Todd" });
	cout << 14 << endl;
	t.insert({ 15, "Will" });
	cout << 15 << endl;
	t.insert({ 18, "Jason" });
	cout << 18 << endl;
	t.insert({ 16, "Kevin" });
	cout << 16 << endl;
	t.insert({ 19, "Bill" });
	cout << 19 << endl;
	t.insert({ 24, "Anthony" });
	cout << 24 << endl;
	t.insert({ 25, "Kate" });
	cout << 25 << endl;
	t.insert({ 26, "Joe" });
	cout << 26 << endl;
	t.insert({ 21, "Alex" });
	cout << 21 << endl;
	t.insert({ 4, "Jen" });
	cout << 4 << endl;
	t.insert({ 5, "Matt" });
	cout << 5 << endl;
	t.insert({ 20, "Danny" });
	cout << 20 << endl;
	t.insert({ 22, "Jack" });
	cout << 22 << endl;
	t.insert({ 2, "Gill" });
	cout << 2 << endl;
	t.insert({ 17, "Evan" });
	cout << 17 << endl;
	t.insert({ 12, "Ian" });
	cout << 12 << endl;
	t.insert({ 6, "Chris" });
	cout << 6 << endl;

	t.insert({ 2, "Gill" });
	cout << 2 << endl;
	t.insert({ 4, "Jen" });
	cout << 4 << endl;
	t.insert({ 3, "Steve" });
	cout << 3 << endl;
	t.insert({ 5, "Matt" });
	cout << 5 << endl;
	t.insert({ 6, "Chris" });
	cout << 6 << endl;
	t.insert({ 7, "Phil" });
	cout << 7 << endl;
	t.insert({ 10, "Zack" });
	cout << 10 << endl;
	t.insert({ 11, "Rick" });
	cout << 11 << endl;
	t.insert({ 12, "Ian" });
	cout << 12 << endl;
	t.insert({ 13, "Mike" });
	cout << 13 << endl;
	t.insert({ 14, "Todd" });
	cout << 14 << endl;
	t.insert({ 15, "Will" });
	cout << 15 << endl;
	t.insert({ 16, "Kevin" });
	cout << 16 << endl;
	t.insert({ 17, "Evan" });
	cout << 17 << endl;
	t.insert({ 18, "Jason" });
	cout << 18 << endl;
	t.insert({ 19, "Bill" });
	cout << 19 << endl;
	t.insert({ 20, "Danny" });
	cout << 20 << endl;
	t.insert({ 21, "Alex" });
	cout << 21 << endl;
	t.insert({ 22, "Jack" });
	cout << 22 << endl;
	t.insert({ 24, "Anthony" });
	cout << 24 << endl;
	t.insert({ 25, "Kate" });
	cout << 25 << endl;
	t.insert({ 26, "Joe" });
	cout << 26 << endl;


	cout << "Traversal of tree constructed is\n";
	t.traverse();
	//t.sync();
	cout << endl;

	cout << "Traversal of index tree constructed is\n";
	//i.traverse();
	cout << endl;

	t.remove({ 1, "Bob" });
	cout << "Traversal of tree after removing 1\n";
	t.traverse();
	cout << endl;

	t.remove({ 13, "Mike" });
	cout << "Traversal of tree after removing 13\n";
	t.traverse();
	cout << endl;

	t.remove({ 7, "Phil" });
	cout << "Traversal of tree after removing 7\n";
	t.traverse();
	cout << endl;

	t.remove({ 4, "Jen" });
	cout << "Traversal of tree after removing 4\n";
	t.traverse();
	cout << endl;

	t.remove({ 2, "Gill" });
	cout << "Traversal of tree after removing 2\n";
	t.traverse();
	cout << endl;

	t.remove({ 16, "Kevin" });
	cout << "Traversal of tree after removing 16\n";
	t.traverse();
	cout << endl;
#endif

	system("pause");
	return 0;
}
